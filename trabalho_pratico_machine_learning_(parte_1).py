# -*- coding: utf-8 -*-
"""Trabalho_pratico_Machine_Learning (Parte 1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jxHvEeAaw3nURMsINRSAISLKohLn2ryG

#Parte 1

##Carregando um conjunto de dados de exemplo
"""

from sklearn import datasets
iris = datasets.load_iris()
digits = datasets.load_digits()

print(digits.data)
print('\n')
print(digits.target)
print('\n')
print(digits.images[0])

"""### Adiconal - Aplicação de funções também no banco de dados Iris"""

print(iris.data[:5])
print('\n')
print(iris.target)

"""##Aprender e prever"""

from sklearn import svm
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier

clf = svm.SVC(gamma=0.001, C=100.)
clf1 = KNeighborsClassifier()
clf2 = RandomForestClassifier(n_estimators=100)

clf.fit(digits.data[:-1], digits.target[:-1])

clf1.fit(digits.data[:-1], digits.target[:-1])

clf2.fit(digits.data[:-1], digits.target[:-1])

print(clf.predict(digits.data[-1:]))
print('\n')
print(clf1.predict(digits.data[-1:]))
print('\n')
print(clf2.predict(digits.data[-1:]))
print('\n')

"""### Adiconal - Aplicação de funções também no banco de dados Iris"""

clf = svm.SVC(gamma=0.001, C=100.)
clf1 = KNeighborsClassifier()
clf2 = RandomForestClassifier(n_estimators=100)

clf.fit(iris.data[:-1], iris.target[:-1])

clf1.fit(iris.data[:-1], iris.target[:-1])

clf2.fit(iris.data[:-1], iris.target[:-1])

print(clf.predict(iris.data[-1:]))
print('\n')
print(clf1.predict(iris.data[-1:]))
print('\n')
print(clf2.predict(iris.data[-1:]))
print('\n')

"""##Convenções"""

import numpy as np
from sklearn import kernel_approximation
from sklearn import datasets
from sklearn.svm import SVC
from sklearn.datasets import load_iris
from sklearn.preprocessing import MultiLabelBinarizer
from sklearn.multiclass import OneVsRestClassifier
from sklearn.preprocessing import LabelBinarizer

rng = np.random.RandomState(0)
X = rng.rand(10, 2000)
X = np.array(X, dtype='float32')
print(X.dtype)
transformer = kernel_approximation.RBFSampler()
X_new = transformer.fit_transform(X)
print(X_new.dtype)

iris = datasets.load_iris()
clf = SVC()
clf.fit(iris.data, iris.target)

clf1 = KNeighborsClassifier()
clf1.fit(iris.data, iris.target)

clf2 = RandomForestClassifier(n_estimators=100)
clf2.fit(iris.data, iris.target)

print(list(clf.predict(iris.data[:3])))
print('\n')
print(list(clf1.predict(iris.data[:3])))
print('\n')
print(list(clf2.predict(iris.data[:3])))
print('\n')

clf.fit(iris.data, iris.target_names[iris.target])

clf1.fit(iris.data, iris.target_names[iris.target])

clf2.fit(iris.data, iris.target_names[iris.target])

print(list(clf.predict(iris.data[:3])))
print('\n')
print(list(clf1.predict(iris.data[:3])))
print('\n')
print(list(clf2.predict(iris.data[:3])))
print('\n')

X, y = load_iris(return_X_y=True)

clf = SVC()
clf.set_params(kernel='linear').fit(X, y)

clf.predict(X[:5])

clf.set_params(kernel='rbf').fit(X, y)

clf.predict(X[:5])

X = [[1, 2], [2, 4], [4, 5], [3, 2], [3, 1]]
y = [0, 0, 1, 1, 2]

classif = OneVsRestClassifier(estimator=SVC(random_state=0))
print(classif.fit(X, y).predict(X))
print('\n')
y = LabelBinarizer().fit_transform(y)
print(classif.fit(X, y).predict(X))

y = [[0, 1], [0, 2], [1, 3], [0, 2, 3], [2, 4]]
y = MultiLabelBinarizer().fit_transform(y)
classif.fit(X, y).predict(X)

"""## Avaliação entre os três modelos de algoritmos utilizados com os dois bancos de dados e os três algoritmos

#### Avaliação com o banco de dados Digits
"""

clf = svm.SVC(gamma=0.001, C=100.)
clf1 = KNeighborsClassifier()
clf2 = RandomForestClassifier(n_estimators=100)

from sklearn.model_selection import train_test_split
from sklearn.datasets import load_digits
X, y = load_digits(return_X_y=True)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=1)

clf.fit(X_train, y_train)

clf1.fit(X_train, y_train)

clf2.fit(X_train, y_train)

est_svm = clf.predict(X_test)
est_knn = clf1.predict(X_test)
est_RFl = clf2.predict(X_test)

import pandas as pd
from sklearn.metrics import accuracy_score
df = pd.DataFrame({
    'Algoritmos': ['SVM', 'KNN', 'RandomForest'],
    'Acuracia': [accuracy_score(y_test, est_svm), accuracy_score(y_test, est_knn), accuracy_score(y_test, est_RFl)]
})

import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, precision_score, recall_score, f1_score, accuracy_score

cm = confusion_matrix(y_test, est_svm)
# Plotar a matriz de confusão
plt.matshow(cm, cmap=plt.cm.Oranges)
plt.colorbar()
for i in range(cm.shape[0]):
    for j in range(cm.shape[1]):
        plt.text(j, i, cm[i, j], ha='center', va='center')
plt.show()

precisao = []
recall = []
f_score = []
acuracia = []

# Calcule a precisão
precisao.append(precision_score(y_test, est_svm, average='macro'))

# Calcule o recall
recall.append(recall_score(y_test, est_svm, average='macro'))

# Calcule o F-score
f_score.append(f1_score(y_test, est_svm, average='macro'))

# Calcule a acurácia
acuracia.append(accuracy_score(y_test, est_svm))

cm = confusion_matrix(y_test, est_knn)
# Plotar a matriz de confusão
plt.matshow(cm, cmap=plt.cm.Oranges)
plt.colorbar()
for i in range(cm.shape[0]):
    for j in range(cm.shape[1]):
        plt.text(j, i, cm[i, j], ha='center', va='center')
plt.show()

# Calcule a precisão
precisao.append(precision_score(y_test, est_knn, average='macro'))

# Calcule o recall
recall.append(recall_score(y_test, est_knn, average='macro'))

# Calcule o F-score
f_score.append(f1_score(y_test, est_knn, average='macro'))

# Calcule a acurácia
acuracia.append(accuracy_score(y_test, est_knn))

cm = confusion_matrix(y_test, est_RFl)
# Plotar a matriz de confusão
plt.matshow(cm, cmap=plt.cm.Oranges)
plt.colorbar()
for i in range(cm.shape[0]):
    for j in range(cm.shape[1]):
        plt.text(j, i, cm[i, j], ha='center', va='center')
plt.show()

# Calcule a precisão
precisao.append(precision_score(y_test, est_RFl, average='macro'))

# Calcule o recall
recall.append(recall_score(y_test, est_RFl, average='macro'))

# Calcule o F-score
f_score.append(f1_score(y_test, est_RFl, average='macro'))

# Calcule a acurácia
acuracia.append(accuracy_score(y_test, est_RFl))

algoritmos = ['SVM', 'KNN', 'RandomForest']

barras = plt.bar(algoritmos, precisao)
plt.title('Comparação das Precisões')
plt.xlabel('Algoritmo')
plt.ylabel('Precisões')
algoritmos = ['SVM', 'KNN', 'RandomForest']
plt.ylim(0.8, 1.02)
plt.yticks(np.arange(0.8, 1.02, 0.02))
for barra in barras:
    yval = barra.get_height()
    plt.text(barra.get_x() + barra.get_width()/3, yval, round(yval, 4), va='bottom')
plt.show()

barras = plt.bar(algoritmos, recall)
plt.title('Comparação dos Recall')
plt.xlabel('Algoritmo')
plt.ylabel('Recall')
plt.ylim(0.8, 1.02)
plt.yticks(np.arange(0.8, 1.02, 0.02))
for barra in barras:
    yval = barra.get_height()
    plt.text(barra.get_x() + barra.get_width()/3, yval, round(yval, 4), va='bottom')
plt.show()

barras = plt.bar(algoritmos, f_score)
plt.title('Comparação dos F_Score')
plt.xlabel('Algoritmo')
plt.ylabel('F_Score')
plt.ylim(0.8, 1.02)
plt.yticks(np.arange(0.8, 1.02, 0.02))
for barra in barras:
    yval = barra.get_height()
    plt.text(barra.get_x() + barra.get_width()/3, yval, round(yval, 4), va='bottom')
plt.show()

barras = plt.bar(algoritmos, acuracia)
plt.title('Comparação das Acurácias')
plt.xlabel('Algoritmo')
plt.ylabel('Acurácia')
plt.ylim(0.8, 1.02)
plt.yticks(np.arange(0.8, 1.02, 0.02))
for barra in barras:
    yval = barra.get_height()
    plt.text(barra.get_x() + barra.get_width()/3, yval, round(yval, 4), va='bottom')
plt.show()

"""#### Avaliação com o banco de dados Iris"""

X, y = load_iris(return_X_y=True)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=1)

clf.fit(X_train, y_train)
clf1.fit(X_train, y_train)
clf2.fit(X_train, y_train)

est_svm = clf.predict(X_test)
est_knn = clf1.predict(X_test)
est_RFl = clf2.predict(X_test)

cm = confusion_matrix(y_test, est_svm)
# Plotar a matriz de confusão
plt.matshow(cm, cmap=plt.cm.Oranges)
plt.colorbar()
for i in range(cm.shape[0]):
    for j in range(cm.shape[1]):
        plt.text(j, i, cm[i, j], ha='center', va='center')
plt.show()

precisao = []
recall = []
f_score = []
acuracia = []

# Calcule a precisão
precisao.append(precision_score(y_test, est_svm, average='macro'))

# Calcule o recall
recall.append(recall_score(y_test, est_svm, average='macro'))

# Calcule o F-score
f_score.append(f1_score(y_test, est_svm, average='macro'))

# Calcule a acurácia
acuracia.append(accuracy_score(y_test, est_svm))

cm = confusion_matrix(y_test, est_knn)
# Plotar a matriz de confusão
plt.matshow(cm, cmap=plt.cm.Oranges)
plt.colorbar()
for i in range(cm.shape[0]):
    for j in range(cm.shape[1]):
        plt.text(j, i, cm[i, j], ha='center', va='center')
plt.show()

# Calcule a precisão
precisao.append(precision_score(y_test, est_knn, average='macro'))

# Calcule o recall
recall.append(recall_score(y_test, est_knn, average='macro'))

# Calcule o F-score
f_score.append(f1_score(y_test, est_knn, average='macro'))

# Calcule a acurácia
acuracia.append(accuracy_score(y_test, est_knn))

cm = confusion_matrix(y_test, est_RFl)
# Plotar a matriz de confusão
plt.matshow(cm, cmap=plt.cm.Oranges)
plt.colorbar()
for i in range(cm.shape[0]):
    for j in range(cm.shape[1]):
        plt.text(j, i, cm[i, j], ha='center', va='center')
plt.show()

# Calcule a precisão
precisao.append(precision_score(y_test, est_RFl, average='macro'))

# Calcule o recall
recall.append(recall_score(y_test, est_RFl, average='macro'))

# Calcule o F-score
f_score.append(f1_score(y_test, est_RFl, average='macro'))

# Calcule a acurácia
acuracia.append(accuracy_score(y_test, est_RFl))

algoritmos = ['SVM', 'KNN', 'RandomForest']
barras = plt.bar(algoritmos, precisao)
plt.title('Comparação das Precisões')
plt.xlabel('Algoritmo')
plt.ylabel('Precisões')
plt.ylim(0.8, 1.02)
plt.yticks(np.arange(0.8, 1.02, 0.02))
for barra in barras:
    yval = barra.get_height()
    plt.text(barra.get_x() + barra.get_width()/3, yval, round(yval, 4), va='bottom')
plt.show()

barras = plt.bar(algoritmos, recall)
plt.title('Comparação dos Recall')
plt.xlabel('Algoritmo')
plt.ylabel('Recall')
plt.ylim(0.8, 1.02)
plt.yticks(np.arange(0.8, 1.02, 0.02))
for barra in barras:
    yval = barra.get_height()
    plt.text(barra.get_x() + barra.get_width()/3, yval, round(yval, 4), va='bottom')
plt.show()

barras = plt.bar(algoritmos, f_score)
plt.title('Comparação dos F_Score')
plt.xlabel('Algoritmo')
plt.ylabel('F_Score')
plt.ylim(0.8, 1.02)
plt.yticks(np.arange(0.8, 1.02, 0.02))
for barra in barras:
    yval = barra.get_height()
    plt.text(barra.get_x() + barra.get_width()/3, yval, round(yval, 4), va='bottom')
plt.show()

barras = plt.bar(algoritmos, acuracia)
plt.title('Comparação das Acurácias')
plt.xlabel('Algoritmo')
plt.ylabel('Acurácia')
plt.ylim(0.8, 1.02)
plt.yticks(np.arange(0.8, 1.02, 0.02))
for barra in barras:
    yval = barra.get_height()
    plt.text(barra.get_x() + barra.get_width()/3, yval, round(yval, 4), va='bottom')
plt.show()